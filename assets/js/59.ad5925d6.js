(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{380:function(v,_,e){"use strict";e.r(_);var t=e(17),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#无服务时代-serverless"}},[v._v("无服务时代（ServerLess）")])]),_("li",[_("a",{attrs:{href:"#远程服务调用"}},[v._v("远程服务调用")])]),_("li",[_("a",{attrs:{href:"#rest设计风格"}},[v._v("REST设计风格")]),_("ul",[_("li",[_("a",{attrs:{href:"#本地事务"}},[v._v("本地事务")])]),_("li",[_("a",{attrs:{href:"#全局事务"}},[v._v("全局事务")])])])]),_("li",[_("a",{attrs:{href:"#共享事务"}},[v._v("共享事务")])]),_("li",[_("a",{attrs:{href:"#分布式事务"}},[v._v("分布式事务")]),_("ul",[_("li",[_("a",{attrs:{href:"#cap"}},[v._v("CAP")])]),_("li",[_("a",{attrs:{href:"#tcc事务"}},[v._v("TCC事务")])]),_("li",[_("a",{attrs:{href:"#saga事务"}},[v._v("SAGA事务")])])])]),_("li",[_("a",{attrs:{href:"#客户端缓存"}},[v._v("客户端缓存")]),_("ul",[_("li",[_("a",{attrs:{href:"#状态缓存"}},[v._v("状态缓存")])]),_("li",[_("a",{attrs:{href:"#强制缓存"}},[v._v("强制缓存")])]),_("li",[_("a",{attrs:{href:"#协商缓存"}},[v._v("协商缓存")])])])]),_("li",[_("a",{attrs:{href:"#域名解析"}},[v._v("域名解析")])]),_("li",[_("a",{attrs:{href:"#传输链路"}},[v._v("传输链路")])]),_("li",[_("a",{attrs:{href:"#内容分发网络"}},[v._v("内容分发网络")]),_("ul",[_("li",[_("a",{attrs:{href:"#路由解析"}},[v._v("路由解析")])]),_("li",[_("a",{attrs:{href:"#内容分发"}},[v._v("内容分发")])]),_("li",[_("a",{attrs:{href:"#cdn应用"}},[v._v("CDN应用")])])])]),_("li",[_("a",{attrs:{href:"#负载均衡"}},[v._v("负载均衡")])]),_("li",[_("a",{attrs:{href:"#数据链路层负载均衡"}},[v._v("数据链路层负载均衡")])]),_("li",[_("a",{attrs:{href:"#网络层负载均衡"}},[v._v("网络层负载均衡")])]),_("li",[_("a",{attrs:{href:"#应用层负载均衡"}},[v._v("应用层负载均衡")])]),_("li",[_("a",{attrs:{href:"#均衡策略与实现"}},[v._v("均衡策略与实现")])]),_("li",[_("a",{attrs:{href:"#服务端缓存"}},[v._v("服务端缓存")])])])]),_("p"),v._v(" "),_("h1",{attrs:{id:"分布式需要考虑的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式需要考虑的问题"}},[v._v("#")]),v._v(" 分布式需要考虑的问题")]),v._v(" "),_("p",[v._v("远程服务在哪里("),_("code",[v._v("服务发现")]),v._v("), 有多少个("),_("code",[v._v("负载均衡")]),v._v(")，网络出现分区、超时或者服务出错怎么办("),_("code",[v._v("熔断、隔离、降级")]),v._v(")，方法的参数与返回结果如何表示("),_("code",[v._v("序列化协议")]),v._v(")，信息如何进行传输("),_("code",[v._v("传输协议")]),v._v(")，服务权限如何管理"),_("code",[v._v("(认证、授权")]),v._v(")，如何保证通信安全("),_("code",[v._v("网络安全层")]),v._v(")，如何令调用不同机器的服务返回相同结果("),_("code",[v._v("分布式数据一致性")]),v._v(")。")]),v._v(" "),_("h1",{attrs:{id:"单体系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单体系统"}},[v._v("#")]),v._v(" 单体系统")]),v._v(" "),_("blockquote",[_("p",[v._v("对于小型系统，单台机器就足以支撑其良好运行的系统，不仅易于开发、测试、部署，且由于系统中各个功能、模块、方法的调用过程都是"),_("code",[v._v("进程内调用")]),v._v("，不会发生进程间通信（Inter-Process Communication，IPC）​，因此连运行效率也是最高的。")])]),v._v(" "),_("p",[v._v("单体意味着"),_("code",[v._v("自包含")]),v._v("。单体应用描述了一种由同一技术平台的不同组件构成的单层软件。")]),v._v(" "),_("blockquote",[_("p",[v._v("单体系统纵向采用"),_("code",[v._v("分层架构")]),v._v("，按照具体职责进行分层，在不同层中采用不同数据结构进行传输。横向角度可以按照技术、功能、业务等维度，将软件拆分成不同模块，以便重用和管理代码。")])]),v._v(" "),_("p",[v._v("单体拆分的难点：拆分之后的自治和隔离能力。\n单体系统的缺点：")]),v._v(" "),_("ul",[_("li",[v._v("单体系统中如果任何一部分代码出现缺陷，过度消耗进程空间内的资源，所造成的影响是全局性的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。")]),v._v(" "),_("li",[v._v("所有代码共享同一个进程，不能隔离，无法（非常难）做到单独更新、停止和升级或某一部分代码。"),_("code",[v._v("可维护性差")])]),v._v(" "),_("li",[v._v("难以技术异构")])]),v._v(" "),_("h1",{attrs:{id:"soa-service-oriented-architecture-面向服务架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#soa-service-oriented-architecture-面向服务架构"}},[v._v("#")]),v._v(" SOA（Service-Oriented Architecture） 面向服务架构")]),v._v(" "),_("p",[v._v("单体拆分几种具有代表性架构：")]),v._v(" "),_("ul",[_("li",[v._v("烟囱式架构：又称信息孤岛，使用这种架构的系统被称为孤岛式信息系统。它指的是一种与其他相关信息系统完全没有互操作或者协调工作的设计模式。")]),v._v(" "),_("li",[v._v("微内核架构：插件式架构。插件可以访问内核中一些公共的资源，但不会直接进行插件之间的交互。")]),v._v(" "),_("li",[v._v("事件驱动架构： 为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道(Event Queue)，来自系统外部的消息将以事件的形式发送至管道中，各个子系统可以从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去。")])]),v._v(" "),_("blockquote",[_("p",[v._v("SOA是一种软件架构设计模式，其核心思想是将应用程序功能划分为一组独立的、可重用的服务。这些服务通过定义良好的接口相互通信，接口通常基于标准协议(HTTP、SOAP、REST等)。")])]),v._v(" "),_("p",[v._v("核心思想：")]),v._v(" "),_("ul",[_("li",[v._v("服务化：将业务逻辑封装成独立的服务，这些服务可以被不同的应用程序或组件调用。")]),v._v(" "),_("li",[v._v("松耦合：服务之间通过标准协议进行通信，尽量减少彼此的依赖，方便扩展和维护。")]),v._v(" "),_("li",[v._v("重用性：服务设计为独立的模块，能够被多个业务场景复用。")]),v._v(" "),_("li",[v._v("可拓展性：通过新增服务轻松拓展系统能力，而无需大规模改造现有系统。")]),v._v(" "),_("li",[v._v("协议独立：服务接口通常基于开放协议，可以支持跨平台、跨语言的交互。\n核心组件：")]),v._v(" "),_("li",[v._v("服务提供者")]),v._v(" "),_("li",[v._v("服务消费者")]),v._v(" "),_("li",[v._v("服务注册中心")]),v._v(" "),_("li",[v._v("服务契约：定义服务接口和交互的协议，包括输入、输出和错误处理。")]),v._v(" "),_("li",[v._v("消息传递：服务之间通过消息总线进行通信，可实现异步通信。")])]),v._v(" "),_("h1",{attrs:{id:"微服务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微服务"}},[v._v("#")]),v._v(" 微服务")]),v._v(" "),_("blockquote",[_("p",[v._v("一种专注于单一职责的、与语言无关的细粒度web服务。微服务是一种通过多个小型服务组合来构建单个应用的架构的风格，这些服务围绕业务能力而非特定的技术标准来构建。")])]),v._v(" "),_("blockquote",[_("p",[v._v("康威定律核心：组织的沟通方式、团队分工和协作结构，会直接影响系统的最终设计和架构。")])]),v._v(" "),_("p",[v._v("微服务的九个核心业务和技术特征：")]),v._v(" "),_("ul",[_("li",[v._v("围绕业务能力构建: 这里再次强调了康威定律的重要性，有怎样结构、规模、能力的团队，就会产生对应结构、规模、能力的产品。")]),v._v(" "),_("li",[v._v("分散治理：服务对应的开发团队有直接对服务运行质量负责的责任以及掌控服务各个方面的权力。")]),v._v(" "),_("li",[v._v("通过服务来实现独立自治的组件。")]),v._v(" "),_("li",[v._v("产品化思维：避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。")]),v._v(" "),_("li",[v._v("数据去中心化：微服务明确提倡数据应该按领域分散管理、更新、维护、存储。")]),v._v(" "),_("li",[v._v("强终端弱管道：减少在通信管道上处理国泰的事情。")]),v._v(" "),_("li",[v._v("容错性设计：接受服务总会出错的显示，能够有自动的机制对其依赖的服务进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。")]),v._v(" "),_("li",[v._v("演进式设计：容错性设计承认服务会出错，演进式设计则承认服务会被报废淘汰。")]),v._v(" "),_("li",[v._v("基础设施自动化：基础设施自动化，如CI/CD的长足发展，显著减少了构建、发布、运维工作的复杂性。由于微服务架构下运维对象数量是单体架构运维对象数量的数量级倍，使用微服务的团队更加依赖于基础设施的自动化，人工是很难支撑成百上千乃至上万级别的服务的。")])]),v._v(" "),_("h2",{attrs:{id:"无服务时代-serverless"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#无服务时代-serverless"}},[v._v("#")]),v._v(" 无服务时代（ServerLess）")]),v._v(" "),_("blockquote",[_("p",[v._v("无服务只设计到两块内容：后端设施(Backed)和函数(Function)。")])]),v._v(" "),_("p",[v._v("后端设施：指的是数据库、消息队列、日志、存储等用于支撑业务逻辑运行，但本身无业务含义的技术组件。\n函数：指的是业务逻辑代码，这里函数的概念与粒度都已经很接近于程序编码角度的函数了，其区别是"),_("code",[v._v("无服务中的函数运行在云端")]),v._v("，不必考虑算力问题，也不必考虑容量规划。")]),v._v(" "),_("p",[v._v("无服务架构适合：")]),v._v(" "),_("ul",[_("li",[v._v("短链接")]),v._v(" "),_("li",[v._v("无状态")]),v._v(" "),_("li",[v._v("适合事件驱动的交互形式。\n无服务不适合：")]),v._v(" "),_("li",[v._v("延迟较低")]),v._v(" "),_("li",[v._v("业务逻辑复杂")]),v._v(" "),_("li",[v._v("有状态")])]),v._v(" "),_("h1",{attrs:{id:"访问远程服务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#访问远程服务"}},[v._v("#")]),v._v(" 访问远程服务")]),v._v(" "),_("blockquote",[_("p",[v._v("远程服务将计算机程序的工作范围从单机扩展至网络，从本地延伸至远程。")])]),v._v(" "),_("h2",{attrs:{id:"远程服务调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#远程服务调用"}},[v._v("#")]),v._v(" 远程服务调用")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：指的是位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的方式使用带宽有限的信道来传输程序控制信息。")])]),v._v(" "),_("p",[v._v("进程间通信的方法：")]),v._v(" "),_("ul",[_("li",[v._v("管道： 分为普通管道和具名管道。")]),v._v(" "),_("li",[v._v("信号： 通知目标进程有某种事件发生。")]),v._v(" "),_("li",[v._v("信号量： 用于进程之间同步协作手段，相当于操作系统提供的一个特殊变量。")]),v._v(" "),_("li",[v._v("消息队列：进程间数量较多的通信的手段，实时性较低。")]),v._v(" "),_("li",[v._v("共享内存： 结合信号量进行同步和互斥的协调操作。")]),v._v(" "),_("li",[v._v("本地套接字接口：可用不同机器之间的进程通信。本地进程通信时，套接字接口经过了优化，不会经过网络协议栈，不需要打包、拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程复制到另一个进程，这种进程间通信方式即本地套接字接口(UNIX Domain Socket)，又叫作IPC Socket。")])]),v._v(" "),_("p",[v._v("RPC的三个基本问题：")]),v._v(" "),_("ul",[_("li",[v._v("如何表示数据： 数据包含传递给方法的参数、方法执行的返回值。基本做法是将交互双方所设计的数据转换为某种事先约定的"),_("code",[v._v("中立数据")]),v._v("格式进行传输。"),_("code",[v._v("序列化和反序列化")]),v._v("。")]),v._v(" "),_("li",[v._v("如何传输数据： 通过网络在两个服务的Endpoint之间相互操作、交换数据。应用层协议，实际传输一般都是基于TCP/IP协议。两个服务交互不是只扔个序列化数据流来表示参数和结果就行的，许多在此之外信息，譬如异常、超时、安全、认证、授权、事务，等等，都可能产生双方需要交换信息的需求。")]),v._v(" "),_("li",[v._v("如何确定方法：在本地方法调用这并不是很大的问题，编译器或者解释器会根据语言规范，将调用的方法的签名转换为进程空间中子进程入口位置的指针。"),_("code",[v._v("接口描述语言")]),v._v("（IDL Interface Description Language）。")])]),v._v(" "),_("p",[v._v("RPC追求的三个指标：")]),v._v(" "),_("ul",[_("li",[v._v("简单")]),v._v(" "),_("li",[v._v("普适")]),v._v(" "),_("li",[v._v("高性能： 两个指标 序列化效率和信息密度(有效载荷占总传输数据比例)。压缩和使用传输层协议减少额外开销。")])]),v._v(" "),_("p",[v._v("RPC框架的转变："),_("code",[v._v("各自都有优点的情况下，整合")])]),v._v(" "),_("ul",[_("li",[v._v("不再追求独立解决RPC的全部三个问题（表示数据、传递数据、确定方法），将部分功能设计为拓展点，用户自行选择，插件化。")]),v._v(" "),_("li",[v._v("追求核心、更高层次的能力，负载均衡、服务注册、可观察性等。")])]),v._v(" "),_("h2",{attrs:{id:"rest设计风格"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rest设计风格"}},[v._v("#")]),v._v(" REST设计风格")]),v._v(" "),_("blockquote",[_("p",[v._v("REST无论是在思想上、概念上还是使用范围上，与RPC都不尽相同。"),_("code",[v._v("思想上差异的核心是抽象的目标不一样，即面向资源的编程思想和面向过程的编程思想两者之间的区别")]),v._v("。概念上REST并不是一种远程服务调用协议，也可以认为根本不是协议，更像一种风格。")])]),v._v(" "),_("p",[v._v("REST的几个关键概念：")]),v._v(" "),_("ul",[_("li",[v._v("资源")]),v._v(" "),_("li",[v._v("表征: 指信息与用户交互时的表示形式。")]),v._v(" "),_("li",[v._v("状态：上下文信息")]),v._v(" "),_("li",[v._v("转移：状态转移")])]),v._v(" "),_("p",[v._v("满足REST风格的系统应该满足以下六大原则：")]),v._v(" "),_("ul",[_("li",[v._v("服务端与客户端分离： 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性。")]),v._v(" "),_("li",[v._v("无状态：REST 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。"),_("code",[v._v("同时也带来更多安全问题，认证、授权")]),v._v("。")]),v._v(" "),_("li",[v._v("可缓存：无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。“降低网络性”的通俗解释是某个功能如果使用有状态的设计只需要一次（或少量）请求就能完成，使用无状态的设计则可能会需要多次请求，或者在请求中带有额外冗余的信息。。为了缓解这个矛盾，REST 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。")]),v._v(" "),_("li",[v._v("分层系统：指客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。"),_("code",[v._v("CDN")])]),v._v(" "),_("li",[v._v("统一接口：REST 希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。")]),v._v(" "),_("li",[v._v("按需代码：可选原则，指的是任何按照客户端的请求，将可执行的软件程序从服务器发送到客户端的请求，按需代码赋予了客户端无需事先直到所有来自服务端的信息应该如何处理、如何运行的宽容度。")])]),v._v(" "),_("p",[v._v("Rest相比RPC的优点，面向资源为主机服务设计的风格好处：")]),v._v(" "),_("ul",[_("li",[v._v("降低服务接口的学习成本。统一接口是REST的重要标志。")]),v._v(" "),_("li",[v._v("资源天然具有集合和层次结构。方法是动词，逻辑上决定每个接口都是互相独立的")]),v._v(" "),_("li",[v._v("REST绑定与HTTP协议。不需要构建网络协议，坏处就是要考虑HTTP协议不提供特性时，没有办法。")])]),v._v(" "),_("h1",{attrs:{id:"事务处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务处理"}},[v._v("#")]),v._v(" 事务处理")]),v._v(" "),_("blockquote",[_("p",[v._v("事务处理几乎在每个信息系统中都会涉及，它存在的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，"),_("code",[v._v("数据状态的一致性")]),v._v("（consistency）。")])]),v._v(" "),_("p",[v._v("要达成数据的一致性要三方面保证：")]),v._v(" "),_("ul",[_("li",[v._v("原子性(Atomic)")]),v._v(" "),_("li",[v._v("隔离性(Isolation)")]),v._v(" "),_("li",[v._v("持久性(durability)")])]),v._v(" "),_("p",[v._v("事务不同场景：")]),v._v(" "),_("ul",[_("li",[v._v("当一个服务只使用一个数据源，通过AID保证一致性是最经典的做法。 内部一致性")]),v._v(" "),_("li",[v._v("当一个服务使用到多个不同的数据源，甚至多个服务同时涉及多个不同的数据源。")])]),v._v(" "),_("h3",{attrs:{id:"本地事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地事务"}},[v._v("#")]),v._v(" 本地事务")]),v._v(" "),_("blockquote",[_("p",[v._v("本地事务是指仅操作"),_("code",[v._v("单一事务资源的")]),v._v("、"),_("code",[v._v("不需要全局事务管理器进行协调")]),v._v("的事务。直接依赖于数据源本身提供的事务能力来工作。"),_("code",[v._v("单个服务使用单个数据源情况下")]),v._v("。")])]),v._v(" "),_("h4",{attrs:{id:"实现原子性和持久性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现原子性和持久性"}},[v._v("#")]),v._v(" 实现原子性和持久性")]),v._v(" "),_("blockquote",[_("p",[v._v("数据必须要成功写入磁盘、磁带等持久化存储器后才拥有持久化，存储在内存的数据遇到crash就会丢失。实现原子性和持久性的最大难题就是“"),_("code",[v._v("写入磁盘”并不是原子的")]),v._v("，不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的"),_("code",[v._v("中间状态")]),v._v("。")])]),v._v(" "),_("p",[v._v("执行事务可能出现以下情况：")]),v._v(" "),_("ul",[_("li",[v._v("未提交事务，写入后崩溃： 程序还没修改完数据，但数据库已经将其中的某些数据变更写入磁盘，此时发生崩溃。撤销修改")]),v._v(" "),_("li",[v._v("已提交事务，写入前崩溃：程序已经修改完事务，提交事务，数据库还没有将数据全部写入磁盘，发生崩溃。 恢复事务修改。")])]),v._v(" "),_("blockquote",[_("p",[v._v("写入中间状态与崩溃都是不可避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，"),_("code",[v._v("崩溃恢复")]),v._v("。")])]),v._v(" "),_("p",[v._v("为了能够顺利地完成崩溃恢复，在磁盘中写入数据就不能像程序修改内存中变量值那样，直接改变某表某行某列的某个值，而是必须将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等。以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化，这种事务实现方法被称为“Commit Logging”（提交日志）。")]),v._v(" "),_("blockquote",[_("p",[v._v("除了日志手段之外，还有一种影子分页的事务实现机制。大体思路是对数据的变更会先写到硬盘的数据中，但并不是直接就地地修改原先的数据，而是将数据复制一份副本，保留原数据，修改副本数据。事务提交之后，修改数据的引用指针。实现更加简单，但涉及到"),_("code",[v._v("隔离性和并发性时事务并发能力相对有限")]),v._v("。")])]),v._v(" "),_("p",[v._v("Commit  Logging的原理清晰，但是Commit Logging存在一个巨大缺陷，所有对数据的真是修改都必须发生在事务提交以后。在此之前即使磁盘有足够空闲、即使某个事务修改的数据量非常大，占用了大量内存缓冲区都不允许提前修改磁盘上的数据。这对提升性能非常不利。")]),v._v(" "),_("p",[v._v("ARIES提出提前写入（Write-Ahead），允许在事务提交之前，提前写入变更数据。")]),v._v(" "),_("p",[v._v("ARIES(基于语义的恢复和隔离算法)按照事务提交时点为界，划分为：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("FORCE")]),v._v("：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。")]),v._v(" "),_("li",[_("strong",[v._v("STEAL")]),v._v("：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。")])]),v._v(" "),_("blockquote",[_("p",[v._v("Commiting Log允许NO-FORCE不允许STEAL.Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL，它给出的解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。`以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除.")])]),v._v(" "),_("p",[v._v("此前记录的用于崩溃恢复时重演数据变动的日志就相应被命名为 Redo Log，一般翻译为“重做日志”.`")]),v._v(" "),_("p",[v._v("Write-Ahead Logging在崩溃恢复时会执行以下三个阶段的操作：")]),v._v(" "),_("ul",[_("li",[v._v("分析阶段： 该阶段从最后一次检查点（Checkpoint），可理解为这个点之前所有应该持久化的变动都已安全落盘开始扫描日志，找出所有没有End Record的事务，组成待恢复的事务集合。这是集合至少会包含Transaction Table和Dirty Page Table。两部分。")]),v._v(" "),_("li",[v._v("重做阶段： 该阶段依据分析阶段中产生的待恢复的事务集合来重演历史，具体操作为：找出所有包含Commit Record的日志，将这些日志的修改写入磁盘，写入完成后再日志中增加一条End Record，然后移除出待恢复事务集合。")]),v._v(" "),_("li",[v._v("回滚操作： 该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，根据Undo Log中的信息，将已经提前写入磁盘的信息重写改写回去，达到回滚操作效果。")])]),v._v(" "),_("p",[v._v("解释一下Transaction Table和Dirty Page Table两大数据库核心数据结构: 用于支持事务的恢复、崩溃恢复和并发管理: 崩溃恢复时会根据日志进行重建")]),v._v(" "),_("ul",[_("li",[v._v("Transaction Table: 数据库内存中的一个表，用于记录当前执行或未完全提交的事务的相关信息。\n"),_("ul",[_("li",[v._v("Transaction Id:唯一标识一个事务的ID")]),v._v(" "),_("li",[v._v("Transaction State： 事务状态。 Active、Committed、Aborted")]),v._v(" "),_("li",[v._v("Last LSN：事务最后一次生成的日志序列号，用于定位该事务的最后一个操作。")]),v._v(" "),_("li",[_("strong",[v._v("Other Metadata")]),v._v("：例如事务开始时间、锁信息等。")])])]),v._v(" "),_("li",[v._v("Dirty Page Table：数据内存中的一个表，用于追踪当前未刷回磁盘的脏页信息。\n"),_("ul",[_("li",[v._v("Page Id:标识脏页的唯一ID。")]),v._v(" "),_("li",[v._v("RecLSN： 标识该页被首次修改时的日志序列号，用于确定恢复日志的起点。")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("重做阶段和回滚阶段都应该涉及为幂等的。")])]),v._v(" "),_("h4",{attrs:{id:"实现隔离性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现隔离性"}},[v._v("#")]),v._v(" 实现隔离性")]),v._v(" "),_("ul",[_("li",[v._v("写锁：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。")]),v._v(" "),_("li",[v._v("读锁： 多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。")]),v._v(" "),_("li",[v._v("范围锁： 对于某个范围直接加排他锁，在这个范围内的数据不能被写入。")])]),v._v(" "),_("blockquote",[_("p",[v._v("并发控制理论： 决定了隔离成都与并发能力是相互抵触的，隔离程度越高，并发访问时的吞吐量就越低。")])]),v._v(" "),_("ul",[_("li",[v._v("串行化")]),v._v(" "),_("li",[v._v("可重复读： 对事务涉及到的数据加读锁和写锁，且一直持有到事务结束，但不在加范围锁。")]),v._v(" "),_("li",[v._v("读已提交：对事务涉及的数据加的写锁会一直持续到事务结束，加的读锁再查询操作结束完成后就马上会释放。")]),v._v(" "),_("li",[v._v("读未提交： "),_("code",[v._v("读未提交")]),v._v("对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。")])]),v._v(" "),_("p",[v._v("无法方案：MVCC，核心版本。适用场景： 一个事务读+一个事务写。")]),v._v(" "),_("blockquote",[_("p",[v._v("认为数据库中每一行记录都存在两个看不见的字段："),_("code",[v._v("CREATE_VERSION")]),v._v(" 和"),_("code",[v._v("DELETE_VERSION")]),v._v("，这两个字段记录的值都是事务 ID，事务 ID 是一个全局严格递增的数值，然后根据以下规则写入数据。")])]),v._v(" "),_("ul",[_("li",[v._v("插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。")]),v._v(" "),_("li",[v._v("删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。")]),v._v(" "),_("li",[v._v("修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制 一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为 空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。")])]),v._v(" "),_("p",[v._v("不同隔离级别下MVCC规则：")]),v._v(" "),_("ul",[_("li",[v._v("可重复读 ：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在 这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。")]),v._v(" "),_("li",[v._v("读已提交 ：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录")])]),v._v(" "),_("h3",{attrs:{id:"全局事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局事务"}},[v._v("#")]),v._v(" 全局事务")]),v._v(" "),_("p",[v._v("全局事务在这里被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。")]),v._v(" "),_("blockquote",[_("p",[v._v("X/Open XA处理事务的架构，其核心内容是"),_("code",[v._v("定义了全局的事务管理器(用于协调全局事务)和局部的资源管理器(驱动本地事务)之间的通信接口")]),v._v("。XA接口是双向的，能在一个事务管理器和多个事务资源管理器之间形成通信桥梁，通过协调多个数据源的一致行动，实现全局事务的统一提交或者回滚。")])]),v._v(" "),_("p",[v._v("JAVA中专门定义了基于XA模式实现了全局事务处理标准JTA，主要两个接口：")]),v._v(" "),_("ul",[_("li",[v._v("事务管理器的接口:"),_("code",[v._v("javax.transaction.TransactionManager")]),v._v(".这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套"),_("code",[v._v("javax.transaction.UserTransaction")]),v._v("接口，用于通过程序代码手动开启、提交和回滚事务。")]),v._v(" "),_("li",[v._v("满足XA规范的资源定义接口: "),_("code",[v._v("javax.transaction.xa.XAResource")]),v._v("，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可。")])]),v._v(" "),_("p",[v._v("XA将事务提交拆分为两阶段(2pc)过程：")]),v._v(" "),_("ul",[_("li",[v._v("准备阶段： 协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则恢复Prepared，否则回复Non-Prepared。")]),v._v(" "),_("li",[v._v("提交阶段： 协调者如果在上一阶段收到所有事务参与者回复的Prepared消息，则先自己在本地持久化事务状态为Commit，在此操作完成后向所有参与者发送Commit指令，所有参与者立即执行提交操作。否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。")])]),v._v(" "),_("p",[v._v("XA协议要保证一致性话需要一些其它前提条件：")]),v._v(" "),_("ul",[_("li",[v._v("必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。同时也假设网络通信在全过程都不会出现误差，不会传递错误的消息。XA协议在准备阶段出现消息丢失可以进行回滚，提交阶段则不行。")]),v._v(" "),_("li",[v._v("必须假设因为网络分区、机器崩溃或者其它原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作。")])]),v._v(" "),_("p",[v._v("两段式提交的缺点：")]),v._v(" "),_("ul",[_("li",[v._v("单点问题： 协调者一旦宕机，所有参与者都必须一直等待。")]),v._v(" "),_("li",[v._v("性能问题：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。")]),v._v(" "),_("li",[v._v("一致性风险： 当网络稳定性和宕机恢复能力假设不成立时，仍可以出现一致性问题。")])]),v._v(" "),_("blockquote",[_("p",[v._v("改进方案（解决两阶段提交的单点问题和准备阶段性能问题），三阶段提交新增了了canCommit阶段(询问状态)，评估事务事务是否有可能顺利完成，在回滚场景下三段式性能要好一点，在正常提交状态会差一点，因为多了一次询问。同时在三段式提交中，如果在PreCommit阶段之后发生了协调者宕机，即参与者没有等到DoCommit的消息的话，默认操作策略是提交事务而不是回滚事务或者持续等待。")])]),v._v(" "),_("p",[v._v("三阶段式提交对单点问题和回滚时的性能问题有所改善，但是对于一致性风险并没有任何改进，反则增加了。比如在PreCommit之后，协调者发出回滚指令但由于网络问题，有些参与者没有收到，则进行了提交，这就会造成不同参与者之间数据不一致的问题。")]),v._v(" "),_("h2",{attrs:{id:"共享事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享事务"}},[v._v("#")]),v._v(" 共享事务")]),v._v(" "),_("blockquote",[_("p",[v._v("共享事务是指多个服务共用同一个数据源。数据源是指提供数据的逻辑设备，不必与物理设备一一对应。")])]),v._v(" "),_("p",[v._v("方案：")]),v._v(" "),_("ul",[_("li",[v._v("让各个服务共享数据库连接。在同一个应用进程中间共享数据库连接并不困难。数据库连接的基础是网络连接，由IP地址和端口绑定，所以为了实现多个服务共享数据库连接必须保证使用者都在一个应用程序中，所以为了实现共享事务必须添加一个"),_("code",[v._v("中间角色")]),v._v(".通过中间角色去和数据库交互。（考虑可行性？ 完全可以成为一个单体项目。 中间角色压力是否多大？）")]),v._v(" "),_("li",[v._v("使用消息队列服务来代替交易服务器。通过消息的消费者来统一处理，实现由本地事务保障的持久化操作。这被称作“"),_("a",{attrs:{href:"https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("单个数据库的消息驱动更新"),_("OutboundLink")],1),v._v("”")])]),v._v(" "),_("h2",{attrs:{id:"分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[v._v("#")]),v._v(" 分布式事务")]),v._v(" "),_("blockquote",[_("p",[v._v("特指多个服务同时访问多个数据源的事务处理机制。")])]),v._v(" "),_("h3",{attrs:{id:"cap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cap"}},[v._v("#")]),v._v(" CAP")]),v._v(" "),_("p",[v._v("这个定理里描述了一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：")]),v._v(" "),_("ul",[_("li",[v._v("一致性(Consistency)： 代表数据在任何时刻、任何分布式节点中看到的都是符合预期。")]),v._v(" "),_("li",[v._v("可用性(Availabilty)： 代表系统不间断地提高服务地能力，理解可用性要先理解于其密切相关地两个指标："),_("code",[v._v("可靠性和可维护性")]),v._v("。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A=MTBF/（MTBF+MTTR）。")]),v._v(" "),_("li",[v._v("分区容忍性(Partition Tolerance)：代表分布式环境中部分阶段因网络而彼此失联后，即与其它节点形成网络分区时，系统仍能够正确提供服务的能力。")])]),v._v(" "),_("blockquote",[_("p",[v._v("而在分布式环境中，“一致性”却不得不成为通常被牺牲、被放弃的那一项属性。引出弱一致性、最终一致性。最终一致性：如果数据在一段时间之内没有被另外操作所更改，那它最终会达到强一致性过程相同的结果。")])]),v._v(" "),_("p",[v._v("柔性事务(分布式事务常见做法)的实现方式：")]),v._v(" "),_("ul",[_("li",[v._v("可靠事件队列：使用 BASE 来达成一致性目的的途径。BASE 分别是基本可用性（"),_("strong",[v._v("B")]),v._v("asically "),_("strong",[v._v("A")]),v._v("vailable）、柔性事务（"),_("strong",[v._v("S")]),v._v("oft State）和最终一致性（"),_("strong",[v._v("E")]),v._v("ventually Consistent）的缩写。")])]),v._v(" "),_("p",[v._v("目标：保证交易过程中正确修改账号、仓库和商家服务中的数据。\n"),_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240303233121.png",alt:"1709479855393.png",referrerpolicy:"no-referrer"}})]),v._v(" "),_("blockquote",[_("p",[v._v("可靠事件队列实现前需要对设计到的操作进行出错概率评估(动态评估)，根据出错概率决定它们的操作顺序。")])]),v._v(" "),_("blockquote",[_("p",[v._v("在此期间要保证消息的幂等性、超时重传。可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败，可能需要手工介入。")])]),v._v(" "),_("p",[v._v("可靠事件队列有一种更普遍的形式，被称为"),_("code",[v._v("最大努力一次提交")]),v._v("，指的是将最可能出错的业务以本地事务的方式完成后，采用不断充实的方式来促使同一个分布式事务中的其它关联业务全部完成。")]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("过程简单")]),v._v(" "),_("li",[v._v("相对可靠\n缺点：")]),v._v(" "),_("li",[v._v("各个事务之间没有隔离性")])]),v._v(" "),_("h3",{attrs:{id:"tcc事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcc事务"}},[v._v("#")]),v._v(" TCC事务")]),v._v(" "),_("blockquote",[_("p",[v._v("可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单（相对于 TCC 来说），但整个过程完全没有任何隔离性可言，有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。比如仓库中超售问题。")])]),v._v(" "),_("p",[v._v("如果需要考虑到隔离性，就需要考虑TCC方案，该方案天生适合需要强隔离性的分布式事务。繁琐，一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程。分为三个阶段：")]),v._v(" "),_("ul",[_("li",[v._v("Try： 尝试执行阶段，完成所有业务可执行的检查（保证一致性），并且预留好全部需用的业务资源（保障隔离性）。")]),v._v(" "),_("li",[v._v("Confirm： 确认执行阶段，不进行任何业务检查，直接使用Try准备的资源进行业务处理。Confirm阶段可能会重复执行，"),_("code",[v._v("保证幂等性")]),v._v("。")]),v._v(" "),_("li",[v._v("Cancel：取消执行阶段，释放Try阶段预留的业务资源，需保证幂等性。\n"),_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240303235707.png",alt:"1709481418466.png",referrerpolicy:"no-referrer"}})])]),v._v(" "),_("blockquote",[_("p",[v._v("类似与2PC准备和提交，但TCC位于用户代码层面，而不是基础设施层面，灵活性高。但同时也带来了更改开发成本和业务侵入性。")])]),v._v(" "),_("h3",{attrs:{id:"saga事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#saga事务"}},[v._v("#")]),v._v(" SAGA事务")]),v._v(" "),_("blockquote",[_("p",[v._v("TCC 的最主要限制是它的业务侵入性很强，这里并不是重复上一节提到的它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。例如支付系统中，银行不会配合你实现Try阶段任务。")])]),v._v(" "),_("p",[v._v("大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。原本 SAGA 的目的是避免大事务长时间锁定数据库的资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。SAGA 由两部分操作组成。")]),v._v(" "),_("ul",[_("li",[v._v("大事务拆分若干个小事务，将整个分布式事务T分解为n个子事务，命名为T1...Tn.每个子事务都应该是或者能被视为原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。")]),v._v(" "),_("li",[v._v("为每个子事务设计 对应的补偿动作。命名为Cx。需满足T和C具备幂等性。满足交换律，限制性T还是先执行C效果一致。C必须能提交完成，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。\n如果T1到Tn全部成功，则事务顺利完成，否则需要采取以下两种恢复策略：")]),v._v(" "),_("li",[v._v("正向恢复：如果 Ti事务提交失败，则一直对 Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景。购物，扣款之后必须发货。")]),v._v(" "),_("li",[v._v("反向恢复：如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止（最大努力交付）。这里要求 Ci必须（在持续重试后）执行成功。")])]),v._v(" "),_("p",[_("code",[v._v("SAGA 必须保证所有子事务都得以提交或者补偿")]),v._v("，但 SAGA 系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为 SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况，譬如执行至哪一步或者补偿至哪一步了。另外，尽管补偿操作通常比冻结/撤销容易实现，但保证正向、反向恢复过程的能严谨地进行也需要花费不少的工夫，譬如通过服务编排、可靠事件队列等方式完成，所以，SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，Seata。")]),v._v(" "),_("h1",{attrs:{id:"透明多级分流系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#透明多级分流系统"}},[v._v("#")]),v._v(" 透明多级分流系统")]),v._v(" "),_("p",[v._v("系统中不同的设施、部件都有各自不同的价值：")]),v._v(" "),_("ul",[_("li",[v._v("位于客户端和网络边缘，能够快速响应用户的请求，避免给后方I/O与CPU带来压力，典型的为本地缓存、内容分发网络、反向代理。")]),v._v(" "),_("li",[v._v("有些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来活得与用户数量相匹配的并发能力。 服务节点")]),v._v(" "),_("li",[v._v("具有全局性的服务或部件，应时刻保持容错备份，维护高可用。")]),v._v(" "),_("li",[v._v("单点部件，只能依赖升级机器本身网络、性能和存储来提升处理能力。")])]),v._v(" "),_("p",[v._v("对系统进行流量规划，有两条原则可以指导我们进行设计：")]),v._v(" "),_("ul",[_("li",[v._v("尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。恰如其分地引导请求分流至最合适的组件中，避免绝大多数流量汇集到单点部件（如数据库），同时依然能够在绝大多数时候保证处理结果的准确性，使单点系统在出现故障时自动而迅速地实施补救措施，这便是系统架构中多级分流的意义。")]),v._v(" "),_("li",[v._v("你应对多级分流的手段有全面的理解与充分的准备，同时清晰地意识到这些设施并不是越多越好。。在实际构建系统时，你应当在有明确需求、真正必要的时候再去考虑部署它们。不是每一个系统都要追求高并发、高可用的，根据系统的用户量、峰值流量和团队本身的技术与运维能力来考虑如何部署这些设施才是合理的做法，在能满足需求的前提下，"),_("strong",[v._v("最简单的系统就是最好的系统")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"客户端缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户端缓存"}},[v._v("#")]),v._v(" 客户端缓存")]),v._v(" "),_("blockquote",[_("p",[v._v("HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷。")])]),v._v(" "),_("p",[v._v("无状态性不可避免造成会携带重复数据，造成网络性能降低。Http协议对此问题的解决方案便是客户端缓存，在 HTTP 从 1.0 到 1.1，再到 2.0 版本的每次演进中，逐步形成了现在被称为“状态缓存”、“强制缓存”（许多资料中简称为“强缓存”）和“协商缓存”的 HTTP 缓存机制。")]),v._v(" "),_("h3",{attrs:{id:"状态缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态缓存"}},[v._v("#")]),v._v(" 状态缓存")]),v._v(" "),_("blockquote",[_("p",[v._v("状态缓存指不经过服务器，客户端直接根据缓存信息对目标网站的状态判断。适用于301/永久重定向，以及HSTS机制（避免依赖301/302跳转HTTPS时可能产生的降级中间人劫持）。")])]),v._v(" "),_("h3",{attrs:{id:"强制缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[v._v("#")]),v._v(" 强制缓存")]),v._v(" "),_("blockquote",[_("p",[v._v("假设在某个时点到来以前，譬如收到响应后的 10 分钟内，资源的内容和状态一定不会被改变，因此客户端可以无须经过任何请求，在该时点前一直持有和使用该资源的本地缓存副本。强制缓存在浏览器的地址输入、页面连接跳转、新开窗口和前进后退均可生效，但在用户主动刷新页面时应当自动失效。")])]),v._v(" "),_("p",[v._v("HTTP协议中设有以下两类header实现强缓存:")]),v._v(" "),_("ul",[_("li",[v._v("Expires: Http/1.0协议中提供的Header，后面跟随一个截至时间参数。当服务器返回某个资源时带有该 Header 的话，意味着服务器承诺截止时间之前资源不会发生变动，浏览器可直接缓存该数据，不再重新发请求。")])]),v._v(" "),_("div",{staticClass:"language-HTTP extra-class"},[_("pre",{pre:!0,attrs:{class:"language-http"}},[_("code",[_("span",{pre:!0,attrs:{class:"token response-status"}},[_("span",{pre:!0,attrs:{class:"token http-version property"}},[v._v("HTTP/1.1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token status-code number"}},[v._v("200")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[v._v("OK")])]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token header"}},[_("span",{pre:!0,attrs:{class:"token header-name keyword"}},[v._v("Expires")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token header-value"}},[v._v("Wed, 8 Apr 2020 07:28:00 GMT")])]),v._v("\n")])])]),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("受限于客户端的本地时间。")]),v._v(" "),_("li",[v._v("无法处理涉及到用户身份的私有资源。譬如，某些资源被登录用户缓存在自己的浏览器上是合理的，但如果被代理服务器或者内容分发网络缓存起来，则可能被其他未认证的用户所获取。")]),v._v(" "),_("li",[v._v("无法描述不缓存语义。")])]),v._v(" "),_("p",[v._v("第二种：")]),v._v(" "),_("ul",[_("li",[v._v("Cache-Control: HTTP/1.1协议中定义的强制缓存Header。如果 Cache-Control 和 Expires 同时存在，并且语义存在冲突（譬如 Expires 与 max-age / s-maxage 冲突）的话，规定必须以 Cache-Control 为准。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("HTTP/1.1 200 OK\nCache-Control: max-age=600\n")])])]),_("p",[v._v("Cache-Control在客户端的请求Header或服务器的响应Header中都可以存在，它定义了一系列参数，且允许自动拓展，其标准的参数主要包括：")]),v._v(" "),_("ul",[_("li",[v._v("max-age和s-maxage: max-age后跟一个以秒为单位的数字，表明相对请求时间多少秒以内缓存有效。s-maxage意味着共享缓存的有效时间，即允许被CDN、带来持有的缓存有效时间。")]),v._v(" "),_("li",[v._v("public和private: 指明是否涉及到用户身份的私有资源，如果是 public，则可以被代理、CDN 等缓存，如果是 private，则只能由用户的客户端进行私有缓存。")]),v._v(" "),_("li",[_("strong",[v._v("no-cache")]),v._v("和"),_("strong",[v._v("no-store")]),v._v("：no-cache 指明该资源不应该被缓存，哪怕是同一个会话中对同一个 URL 地址的请求，也必须从服务端获取，令强制缓存完全失效，但此时下一节中的协商缓存机制依然是生效的；no-store 不强制会话中相同 URL 资源的重复获取，但禁止浏览器、CDN 等以任何形式保存该资源。")]),v._v(" "),_("li",[_("strong",[v._v("no-transform")]),v._v("：禁止资源被任何形式地修改。")]),v._v(" "),_("li",[_("strong",[v._v("min-fresh")]),v._v("和"),_("strong",[v._v("only-if-cached")]),v._v("：这两个参数是仅用于客户端的请求 Header。min-fresh 后续跟随一个以秒为单位的数字，用于建议服务器能返回一个不少于该时间的缓存资源（即包含 max-age 且不少于 min-fresh 的数字）。only-if-cached 表示客户端要求不必给它发送资源的具体内容，此时客户端就仅能使用事先缓存的资源来进行响应，若缓存不能命中，就直接返回 503/Service Unavailable 错误。")]),v._v(" "),_("li",[_("strong",[v._v("must-revalidate")]),v._v("和"),_("strong",[v._v("proxy-revalidate")]),v._v("：must-revalidate 表示在资源过期后，一定需要从服务器中进行获取，即超过了 max-age 的时间后，就等同于 no-cache 的行为，proxy-revalidate 用于提示代理、CDN 等设备资源过期后的缓存行为，除对象不同外，语义与 must-revalidate 完全一致。")])]),v._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),_("p",[v._v("强制缓存是基于"),_("code",[v._v("时效性")]),v._v("的，但无论是人还是服务器，其实多数情况下都并没有什么把握去承诺某项资源多久不会发生变化。另外一种"),_("code",[v._v("基于变化检测")]),v._v("的缓存机制，在"),_("code",[v._v("一致性")]),v._v("上会有比强制缓存更好的表现，但需要一次变化检测的交互开销，性能上就会略差一些，这种基于检测的缓存机制，通常被称为“协商缓存”。")]),v._v(" "),_("blockquote",[_("p",[v._v("协商缓存与强制缓存并没有互斥性，两套机制是并行工作的。")])]),v._v(" "),_("p",[v._v("协商缓存有两种变动检查机制，分别是根据资源的"),_("code",[v._v("修改时间")]),v._v("进行检查，以及根据资源"),_("code",[v._v("唯一标识")]),v._v("是否发生变化来进行检查，它们都是靠一组成对出现的请求、响应 Header 来实现的：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Last-Modified 和 If-Modified-Since")]),v._v("：Last-Modified 是服务器的响应 Header，用于告诉客户端这个资源的最后修改时间。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-Modified-Since 把之前收到的资源最后修改时间发送回服务端。\n如果此时服务端发现资源在该事件后没有被修改，就只要返回一个304/Not Modified的响应，不需要返回消息体。否则返回200的完整响应。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("HTTP/1.1 304 Not Modified\nCache-Control: public, max-age=600\nLast-Modified: Wed, 8 Apr 2020 15:31:30 GMT\n")])])]),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("HTTP/1.1 200 OK\nCache-Control: public, max-age=600\nLast-Modified: Wed, 8 Apr 2020 15:31:30 GMT\n\nContent\n")])])]),_("ul",[_("li",[_("strong",[v._v("Etag 和 If-None-Match")]),v._v("：Etag 是服务器的响应 Header，用于告诉客户端这个资源的唯一标识。HTTP服务器可以根据自己意愿来生成这个标识，譬如 Apache 服务器的 Etag 值默认是对文件的索引节点（INode），大小和最后修改时间进行哈希计算后得到的。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-None-Match 把之前收到的资源唯一标识发送回服务端。如果此时服务端计算后发现资源的唯一标识与上传回来的一致，说明资源没有被修改过，就只要返回一个 304/Not Modified 的响应即可，无须附带消息体，达到节省流量的目的。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('HTTP/1.1 304 Not Modified\nCache-Control: public, max-age=600\nETag: "28c3f612-ceb0-4ddc-ae35-791ca840c5fa"\n')])])]),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('HTTP/1.1 200 OK\nCache-Control: public, max-age=600\nETag: "28c3f612-ceb0-4ddc-ae35-791ca840c5fa"\n\nContent\n')])])]),_("blockquote",[_("p",[v._v("Etag是HTTP中一致性最好的缓存机制。Last-Modified存在的问题 只能精确到秒级、定期生成文件内容没有发生变化。Etag是性能最差的Http缓存机制，服务器每次请求都要进行计算。")])]),v._v(" "),_("blockquote",[_("p",[v._v("协商缓存不仅在浏览器输入、页面链接跳转、新开窗口、前进、后退中生效，在用户主动刷新页面也生效。强制刷新和明确禁用缓存会失效。")])]),v._v(" "),_("h2",{attrs:{id:"域名解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#域名解析"}},[v._v("#")]),v._v(" 域名解析")]),v._v(" "),_("p",[v._v("DNS解析步骤：")]),v._v(" "),_("ul",[_("li",[v._v("客户端先检查本地的DNS缓存，查看是否存在并且存活者该域名的地址记录，DNS采用"),_("code",[v._v("存活时间")]),v._v("来衡量缓存的有效情况。")]),v._v(" "),_("li",[v._v("客户端将地址发送给本机操作系统中配置的"),_("code",[v._v("本地 DNS（Local DNS")]),v._v("），这个本地 DNS 服务器可以由用户手工设置，也可以在 DHCP 分配时或者在拨号时从 PPP 服务器中自动获取到。")]),v._v(" "),_("li",[v._v("本地DNS收到查询请求后，会按照“是否有"),_("code",[v._v("www.icyfenix.com.cn")]),v._v("的权威服务器”→“是否有"),_("code",[v._v("icyfenix.com.cn")]),v._v("的权威服务器”→“是否有"),_("code",[v._v("com.cn")]),v._v("的权威服务器”→“是否有"),_("code",[v._v("cn")]),v._v("的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止.")])]),v._v(" "),_("blockquote",[_("p",[v._v("权威域名服务器：指负责翻译特定域名的DNS服务器，“权威”意味着这个域名应该翻译出怎样的结果是由它来决定的。\n根域名服务器：指固定的、无需查询顶级域名服务器。全世界一共有 13 组根域名服务器，13 这个数字是由于 DNS 主要采用 UDP 传输协议来进行数据交换，未分片的 UDP 数据包在 IPv4 下最大有效值为 512 字节，最多可以存放 13 组地址记录，由此而来的限制。")])]),v._v(" "),_("ul",[_("li",[v._v("现在假设本地 DNS 是全新的，上面不存在任何域名的权威服务器记录，所以当 DNS 查询请求按步骤 3 的顺序一直查到根域名服务器之后，它将会得到“"),_("code",[v._v("cn")]),v._v("的权威服务器”的地址记录，然后通过“"),_("code",[v._v("cn")]),v._v("的权威服务器”，得到“"),_("code",[v._v("com.cn")]),v._v("的权威服务器”的地址记录，以此类推，最后找到能够解释"),_("code",[v._v("www.icyfenix.com.cn")]),v._v("的权威服务器地址。")]),v._v(" "),_("li",[v._v("通过“"),_("code",[v._v("www.icyfenix.com.cn")]),v._v("的权威服务器”，查询"),_("code",[v._v("www.icyfenix.com.cn")]),v._v("的地址记录，地址记录并不一定就是指 IP 地址，在 RFC 规范中有定义的地址记录类型已经"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/List_of_DNS_record_types",target:"_blank",rel:"noopener noreferrer"}},[v._v("多达数十种"),_("OutboundLink")],1),v._v("，譬如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、主机别名 CNAME 记录，等等。")])]),v._v(" "),_("blockquote",[_("p",[v._v("DNS 系统多级分流的设计使得 DNS 系统能够经受住全球网络流量不间断的冲击，但也并非全无缺点。典型的问题是响应速度，当极端情况（各级服务器均无缓存）下的域名解析可能导致每个域名都必须递归多次才能查询到结果，显著影响传输的响应速度。可以使用"),_("code",[v._v("DNS预取")]),v._v("的前端手段来避免这个问题,提前进行域名解析。通过多级缓存机制意味着被劫持的风险变大了。出现了"),_("code",[v._v("HTTPDNS")]),v._v("手段解决这个问题。")])]),v._v(" "),_("h2",{attrs:{id:"传输链路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输链路"}},[v._v("#")]),v._v(" 传输链路")]),v._v(" "),_("p",[v._v("连接数优化：")]),v._v(" "),_("blockquote",[_("p",[v._v("HTTP以TCP为基础，但HTTP传输对象的特征： 数量多、时间短、资源小、切换快的特点和TCP要进行三次握手和慢启动等特性并不协调。TCP本身是面向长时间、大数据传输来设计的。")])]),v._v(" "),_("p",[v._v("连接复用：Keep-Alive机制，持久连接的原理"),_("code",[v._v("就是让客户端对同一个域名长期持有一个或多个不会用完即断的TCP连接")]),v._v("。避免创建TCP连接的成本。FIFO队列")]),v._v(" "),_("p",[v._v("客户端FIFO队列连接复用技术仍然不是完美的，最明显的副作用是"),_("code",[v._v("队首阻塞")]),v._v("。浏览器有 10 个资源需要从服务器中获取，此时它将 10 个资源放入队列，入列顺序只能按照浏览器遇见这些资源的先后顺序来决定的，如果第一个要消耗很大时间，后面请求的资源就必须阻塞等待。 根本原因就是 只使用一个TCP连接传输多个资源，如果顺序乱了，客户端很难区分哪个数据包归属哪个资源。 改善，客户端直接将需要的数据一同传输给服务端，由服务端创建队列来完成资源排序返回。缺点： 需要多方共同支持，协调比较困难。")]),v._v(" "),_("p",[v._v("HTTP多路复用技术。")]),v._v(" "),_("p",[v._v("HTTP2比较完美解决了队首阻塞问题，HTTP/1.X中，http请求就是传输过程中最小粒度的信息单位，HTTP/2,帧才是最小粒度单位，它可以用来描述各种数据。每个帧都附带一个流 ID 以标识这个帧属于哪个流。这样，在同一个 TCP 连接中传输的多个数据帧就可以根据流 ID 轻易区分出开来，在客户端毫不费力地将不同流中的数据重组出不同 HTTP 请求和响应报文来。有了多路复用，HTTP2就可以对每个域名只维持一个TCP连接来以任意顺序传输任意数量的资源。")]),v._v(" "),_("p",[v._v("HTTP2中专门考虑了Header压缩的问题。Header压缩的原理是基于字典编码的信息复用，同一个连接上产生的请求和相应越多，动态字典积累的越全，头部要锁效果也越好。")]),v._v(" "),_("p",[v._v("传输压缩")]),v._v(" "),_("blockquote",[_("p",[v._v("对文本数据启用压缩的收益是非常高的。")])]),v._v(" "),_("p",[v._v("复用连接和即使压缩本身是矛盾的，即使压缩为了提高单字节相应速度，不会等待数据全部进行压缩之后才发送，导致无法获取到Content-Length数值，多路复用技术就无法判断这个资源是否传输完毕。 HTTP/1.1 增加了分块传输编码的资源结束判断机制，解决了这个问题。")]),v._v(" "),_("p",[v._v("快速UDP网络连接")]),v._v(" "),_("p",[v._v("要由自己保证可靠传输。QUIC 在移动设备上的优势体现在网络切换时的响应速度上，譬如当移动设备在不同 WiFi 热点之间切换，或者从 WiFi 切换到移动网络时，如果使用 TCP 协议，现存的所有连接都必定会超时、中断，然后根据需要重新创建。这个过程会带来很高的延迟，因为超时和重新握手都需要大量时间。为此，QUIC 提出了"),_("code",[v._v("连接标识符")]),v._v("的概念，该标识符可以唯一地标识客户端与服务器之间的连接，而无须依靠 IP 地址。这样，切换网络后，只需向服务端发送一个包 含此标识符的数据包即可重用既有的连接，因为即使用户的 IP 地址发生变化，原始连接连 接标识符依然是有效的。")]),v._v(" "),_("h2",{attrs:{id:"内容分发网络"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内容分发网络"}},[v._v("#")]),v._v(" 内容分发网络")]),v._v(" "),_("p",[v._v("仅从网络传输的角度分析，一个互联网系统的速度取决于：")]),v._v(" "),_("ul",[_("li",[v._v("网络服务器接入网络运营商的链路所能提供的出口带宽。")]),v._v(" "),_("li",[v._v("用户客户端接入网络运营商的链路所能提供的入口带宽。")]),v._v(" "),_("li",[v._v("从网站到用户之间经过的不同运营商之间互联节点的带宽，一般来说两个运营商之间只有固定的若干个点是互通的，所有跨运营商之间的交互都要经过这些点。")]),v._v(" "),_("li",[v._v("从网站到用户之间的物理链路传输时延。")])]),v._v(" "),_("blockquote",[_("p",[v._v("一个运作良好的内容分发网络，能为互联网系统解决跨运营商、跨地域物理距离所导致的时延问题，能为网站流量带宽起到分流、减负的作用.")])]),v._v(" "),_("p",[v._v("内容分发网络的工作过程，主要涉及路由解析、内容分发、负载均衡和所能支持的CDN应用。")]),v._v(" "),_("h3",{attrs:{id:"路由解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#路由解析"}},[v._v("#")]),v._v(" 路由解析")]),v._v(" "),_("blockquote",[_("p",[v._v("内容分发网络将用户请求路由到它的资源服务器上就是依靠 DNS 服务器来实现的。")])]),v._v(" "),_("p",[v._v("CDN 路由解析的具体工作过程是：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("架设好“"),_("code",[v._v("icyfenix.cn")]),v._v("”的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为“源站”，注册后你会得到一个 CNAME，即本例中的“"),_("code",[v._v("icyfenix.cn.cdn.dnsv1.com.")]),v._v("”。")])]),v._v(" "),_("li",[_("p",[v._v("将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。")])]),v._v(" "),_("li",[_("p",[v._v("当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。")])]),v._v(" "),_("li",[_("p",[v._v("本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。")])]),v._v(" "),_("li",[_("p",[v._v("浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问，此时该 IP 的 CDN 节点上可能有，也可能没有缓存过源站的资源，这点将在稍后“"),_("a",{attrs:{href:"https://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cdn.html#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91",target:"_blank",rel:"noopener noreferrer"}},[v._v("内容分发"),_("OutboundLink")],1),v._v("”小节讨论。")])]),v._v(" "),_("li",[_("p",[v._v("经过内容分发后的 CDN 节点，就有能力代替源站向用户提供所请求的资源。")])])]),v._v(" "),_("h3",{attrs:{id:"内容分发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内容分发"}},[v._v("#")]),v._v(" 内容分发")]),v._v(" "),_("p",[v._v("路由解析依靠DNS服务器，之后出现了两个问题：如何获取源站资源”和“如何管理（更新）资源。")]),v._v(" "),_("p",[v._v("两种主流的内容分发方式：")]),v._v(" "),_("ul",[_("li",[v._v("主动分发：分发由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。主动分发一般用于网站要预载大量资源的场景。例如双十一等场景。")]),v._v(" "),_("li",[v._v("被动回溯： 被动回源由用户访问所触发全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点发现自己没有该资源，就会实时从源站中获取，这时资源的响应时间可粗略认为是资源从源站到 CDN 缓存节点的时间，再加上资源从 CDN 发送到用户的时间之和。不适用于数据量较大的资源，"),_("code",[v._v("双向透明")]),v._v("。")])]),v._v(" "),_("p",[v._v("更新资源最常见的方式：")]),v._v(" "),_("ul",[_("li",[v._v("超时被动失效:给予缓存资源一定的生存期，超过了生存期就在下次请求时重新被动回源一次")]),v._v(" "),_("li",[v._v("手工主动失效:  CDN 服务商一般会提供给程序调用来失效缓存的接口，在网站更新时，由持续集成的流水线自动调用该接口来实现缓存更新")])]),v._v(" "),_("h3",{attrs:{id:"cdn应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn应用"}},[v._v("#")]),v._v(" CDN应用")]),v._v(" "),_("p",[v._v("CDN能做的事情：")]),v._v(" "),_("ul",[_("li",[v._v("加速静态资源。")]),v._v(" "),_("li",[v._v("安全防御： DN 在广义上可以视作网站的堡垒机，源站只对 CDN 提供服务，由 CDN 来对外界其他用户服务，这样恶意攻击者就不容易直接威胁源站。CDN 对某些攻击手段的防御，如对"),_("a",{attrs:{href:"https://zh.wikipedia.org/zh-tw/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A",target:"_blank",rel:"noopener noreferrer"}},[v._v("DDoS 攻击"),_("OutboundLink")],1),v._v("的防御尤其有效。")]),v._v(" "),_("li",[v._v("协议升级： 不少 CDN 提供商都同时对接（代售 CA 的）SSL 证书服务，可以实现源站是 HTTP 协议的，而对外开放的网站是基于 HTTPS 的。")]),v._v(" "),_("li",[v._v("状态缓存： CDN 不仅可以缓存源站的资源，还可以缓存源站的状态，譬如源站的 301/302 转向就可以缓存起来让客户端直接跳转、还可以通过 CDN 开启"),_("a",{attrs:{href:"https://es.wikipedia.org/wiki/HTTP_Strict_Transport_Security",target:"_blank",rel:"noopener noreferrer"}},[v._v("HSTS"),_("OutboundLink")],1),v._v("、可以通过 CDN 进行"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2",target:"_blank",rel:"noopener noreferrer"}},[v._v("OCSP 装订"),_("OutboundLink")],1),v._v("加速 SSL 证书访问，等等")]),v._v(" "),_("li",[v._v("修改资源： DN 可以在返回资源给用户的时候修改它的任何内容，以实现不同的目的。譬如，可以对源站未压缩的资源自动压缩并修改 Content-Encoding，以节省用户的网络带宽消耗、可以对源站未启用客户端缓存的内容加上缓存 Header，自动启用客户端缓存，可以修改"),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/CORS",target:"_blank",rel:"noopener noreferrer"}},[v._v("CORS"),_("OutboundLink")],1),v._v("的相关 Header，将源站不支持跨域的资源提供跨域能力，等等。")]),v._v(" "),_("li",[v._v("访问控制： CDN能实现IP黑白名单功能，根据不同IP提供不同响应结果。根据 IP 的访问流量来实现 QoS 控制、根据 HTTP 的 Referer 来实现防盗链。")]),v._v(" "),_("li",[v._v("注入功能： CDN 可以在不修改源站代码的前提下，为源站注入各种功能.")])]),v._v(" "),_("h2",{attrs:{id:"负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),_("blockquote",[_("p",[v._v("概念： 调度后方的多方机器，以统一的接口对外提供服务，承担此职责的技术组件被成为负载均衡。")])]),v._v(" "),_("p",[v._v("真正的大型系统的负载均衡过程往往是多级的。在各地建有多个机房，或机房有不同网络链路入口的大型互联网站，会从DNS解析开始，域名->CNAME->负载均衡调度服务->就近的数据中心入口，根据来访用户根据IP地址分配到一个合适的数据中心。")]),v._v(" "),_("p",[v._v("无论在网关内部建了多少级负载均衡，从形式上来说可以分为两种：")]),v._v(" "),_("ul",[_("li",[v._v("四层负载（传输层）： 性能高。共同特点是维持着同一个TCP连接，并不是只工作在第四层。")]),v._v(" "),_("li",[v._v("七层负载（应用层）： 功能强。")])]),v._v(" "),_("h2",{attrs:{id:"数据链路层负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层负载均衡"}},[v._v("#")]),v._v(" 数据链路层负载均衡")]),v._v(" "),_("p",[v._v("传输内容为数据帧。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[_("strong",[v._v("数据项")])]),v._v(" "),_("th",[_("strong",[v._v("取值")])])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("前导码")]),v._v(" "),_("td",[v._v("10101010 7 Bytes")])]),v._v(" "),_("tr",[_("td",[v._v("帧开始符")]),v._v(" "),_("td",[v._v("10101011 1 Byte")])]),v._v(" "),_("tr",[_("td",[v._v("MAC 目标地址")]),v._v(" "),_("td",[v._v("6 Bytes")])]),v._v(" "),_("tr",[_("td",[v._v("MAC 源地址")]),v._v(" "),_("td",[v._v("6 Bytes")])]),v._v(" "),_("tr",[_("td",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/IEEE_802.1Q",target:"_blank",rel:"noopener noreferrer"}},[v._v("802.1Q"),_("OutboundLink")],1),v._v("标签（可选）")]),v._v(" "),_("td",[v._v("4 Bytes")])]),v._v(" "),_("tr",[_("td",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Ethertype",target:"_blank",rel:"noopener noreferrer"}},[v._v("以太类型"),_("OutboundLink")],1)]),v._v(" "),_("td",[v._v("2 Bytes")])]),v._v(" "),_("tr",[_("td",[v._v("有效负载")]),v._v(" "),_("td",[v._v("1500 Bytes")])]),v._v(" "),_("tr",[_("td",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C",target:"_blank",rel:"noopener noreferrer"}},[v._v("冗余校验"),_("OutboundLink")],1)]),v._v(" "),_("td",[v._v("4 Bytes")])]),v._v(" "),_("tr",[_("td",[_("a",{attrs:{href:"https://zh.wikipedia.org/w/index.php?title=%E5%B8%A7%E9%97%B4%E8%B7%9D&action=edit&redlink=1",target:"_blank",rel:"noopener noreferrer"}},[v._v("帧间距"),_("OutboundLink")],1)]),v._v(" "),_("td",[v._v("12 Bytes")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("数据链路层负载均衡所做的工作，是"),_("code",[v._v("修改请求的数据帧中的 MAC 目标地址")]),v._v("，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（后文称为“真实服务器”，Real Server）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。二层负载均衡器在转发请求过程中只修改了帧的MAC目标地址，不涉及更上层协议，第三层数据包，IP数据包中包含了源客户端和目标IP地址，"),_("code",[v._v("只有真实服务器保证自己的 IP 地址与数据包中的目标 IP 地址一致，这个数据包才能被正确处理")]),v._v("。因此，使用这种负载均衡模式时，需要把真实物理服务器集群所有机器的"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Virtual_IP_address",target:"_blank",rel:"noopener noreferrer"}},[v._v("虚拟 IP 地址"),_("OutboundLink")],1),v._v("（Virtual IP Address，VIP）配置成与负载均衡器的虚拟 IP 一样，这样经均衡器转发后的数据包就能在真实服务器中顺利地使用。也正是因为实际处理请求的真实物理服务器 IP 和数据请求中的目的 IP 是一致的，所以"),_("code",[v._v("响应结果就不再需要通过负载均衡服务器进行地址交换，可将响应结果的数据包直接从真实服务器返回给用户的客户端")]),v._v("，避免负载均衡器网卡带宽成为瓶颈，因此数据链路层的负载均衡效率是相当高的。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240409003605.png",alt:"1712594121616.png",referrerpolicy:"no-referrer"}})]),v._v(" "),_("p",[v._v("整个请求、转发、响应的链路形成一个三角关系，通常也被称为三角传输模式或者直接路由。负载效率很高。")]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("那些需要感知应用层协议信息的负载均衡场景它无法胜任。")]),v._v(" "),_("li",[v._v("二层负载均衡器直接改写目标 MAC 地址的工作原理决定了它与真实的服务器的通信必须是二层可达的，通俗地说就是必须位于同一个子网当中，无法跨 VLAN。")])]),v._v(" "),_("p",[v._v("效率高和不能跨子网决定数据链路层负载均衡最适合用来做数据中心的第一层均衡设备，用来连接其它的下级负载均衡器。")]),v._v(" "),_("h2",{attrs:{id:"网络层负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络层负载均衡"}},[v._v("#")]),v._v(" 网络层负载均衡")]),v._v(" "),_("p",[v._v("传输单位为分组数据包。")]),v._v(" "),_("p",[v._v("以 IP 协议为例，一个 IP 数据包由 Headers 和 Payload 两部分组成， Headers 长度最大为 60 Bytes，其中包括了 20 Bytes 的固定数据和最长不超过 40 Bytes 的可选的额外设置组成。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("长度")]),v._v(" "),_("th",[v._v("存储信息")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("0-4 Bytes")]),v._v(" "),_("td",[v._v("版本号（4 Bits）、首部长度（4 Bits）、分区类型（8 Bits)、总长度（16 Bits）")])]),v._v(" "),_("tr",[_("td",[v._v("5-8 Bytes")]),v._v(" "),_("td",[v._v("报文计数标识（16 Bits）、标志位（4 Bits）、片偏移（12 Bits）")])]),v._v(" "),_("tr",[_("td",[v._v("9-12 Bytes")]),v._v(" "),_("td",[v._v("TTL 生存时间（8 Bits）、上层协议代号（8 Bits）、首部校验和（16 Bits）")])]),v._v(" "),_("tr",[_("td",[v._v("13-16 Bytes")]),v._v(" "),_("td",[v._v("源地址（32 Bits）")])]),v._v(" "),_("tr",[_("td",[v._v("17-20 Bytes")]),v._v(" "),_("td",[v._v("目标地址（32 Bits）")])]),v._v(" "),_("tr",[_("td",[v._v("20-60 Bytes")]),v._v(" "),_("td",[v._v("可选字段和空白填充")])])])]),v._v(" "),_("p",[v._v("通过改变IP地址来实现数据包的转发,有两种常见的修改方式：")]),v._v(" "),_("ul",[_("li",[v._v("保持原有数据包不变，创建新的数据包。把原来数据包的 Headers 和 Payload 整体作为另一个新的数据包的 Payload，在这个新数据包的 Headers 中写入真实服务器的 IP 作为目标地址，然后把它发送出去。IP隧道。仍然具有三角传输的特性。\n"),_("ul",[_("li",[v._v("要求真实服务器必须支持IP隧道协议。")]),v._v(" "),_("li",[v._v("必须保证所有的真实服务器与均衡器有着相同的虚拟IP地址。")])])]),v._v(" "),_("li",[v._v("修改目标数据包： 直接把数据包 Headers 中的目标地址改掉，修改后原本由用户发给均衡器的数据包.真实服务器应答流量需要继续回到负载均衡器。NAT模式。\n"),_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240409004722.png",alt:"1712594829777.png",referrerpolicy:"no-referrer"}})])]),v._v(" "),_("p",[v._v("会被负载均衡器的带宽所影响。")]),v._v(" "),_("p",[v._v("还有一种更加彻底的 NAT 模式：即均衡器在转发时，不仅修改目标 IP 地址，连源 IP 地址也一起改了，源地址就改成均衡器自己的 IP，称作 Source NAT（SNAT）。这样做的好处是真实服务器无须配置网关就能够让应答流量经过正常的三层路由回到负载均衡器上，做到了彻底的透明。但是缺点是由于做了 SNAT，真实服务器处理请求时就无法拿到客户端的 IP 地址了，从真实服务器的视角看来，所有的流量都来自于负载均衡器，这样有一些需要根据目标 IP 进行控制的业务逻辑就无法进行")]),v._v(" "),_("h2",{attrs:{id:"应用层负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用层负载均衡"}},[v._v("#")]),v._v(" 应用层负载均衡")]),v._v(" "),_("p",[v._v("前面介绍的四层负载均衡工作模式都属于“转发”，即直接将承载着 TCP 报文的底层数据格式（IP 数据包或以太网帧）转发到真实服务器上，此时"),_("code",[v._v("客户端到响应请求的真实服务器维持着同一条 TCP 通道")]),v._v("。但工作在四层之后的负载均衡模式就无法再进行转发了，只能进行代理，此时真实服务器、负载均衡器、客户端三者之间由两条独立的 TCP 通道来维持通信，转发与代理的区别\n"),_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240409005056.png",alt:"1712595045508.png",referrerpolicy:"no-referrer"}})]),v._v(" "),_("p",[v._v("代理分为：")]),v._v(" "),_("ul",[_("li",[v._v("正向代理：")]),v._v(" "),_("li",[v._v("反向代理")]),v._v(" "),_("li",[v._v("透明代理： 指对双方都透明的，配置在网络中间设备上的代理服务，譬如，架设在路由器上的透明翻墙代理。")])]),v._v(" "),_("p",[v._v("七层负载均衡器属于反向代理，性能比不上四层均衡负载器，也存在NAT转发模式一样的带宽问题，更占用CPU资源。但可用解析规则比四层丰富。")]),v._v(" "),_("h2",{attrs:{id:"均衡策略与实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#均衡策略与实现"}},[v._v("#")]),v._v(" 均衡策略与实现")]),v._v(" "),_("p",[v._v("负载均衡的两大职责是“选择谁来处理用户请求”和“将用户请求转发过去.")]),v._v(" "),_("p",[v._v("常见均衡策略：")]),v._v(" "),_("ul",[_("li",[v._v("轮询策略： 适用于集群中所有服务器都有相同软硬件配置并且平均服务请求相对均衡的情况。")]),v._v(" "),_("li",[v._v("权重轮询策略： 根据不同服务器的处理能力，分配不同的权值。")]),v._v(" "),_("li",[v._v("随机均衡： 随机分配给内部的多个服务器")]),v._v(" "),_("li",[v._v("权重随机：此种均衡算法类似于权重轮循算法，不过在分配处理请求时是个随机选择的过程。")]),v._v(" "),_("li",[v._v("一致性哈希均衡： 根据请求中某一些数据（可以是 MAC、IP 地址，也可以是更上层协议中的某些参数信息）作为特征值来计算需要落在的节点上，算法一般会保证同一个特征值每次都一定落在相同的服务器上。一致性的意思是保证当服务集群某个真实服务器出现故障，只影响该服务器的哈希，而不会导致整个服务集群的哈希键值重新分布。")]),v._v(" "),_("li",[v._v("响应速度均衡： 发出探测请求，然后根据响应时间来决定哪一个服务器来响应客户端请求。")]),v._v(" "),_("li",[v._v("最少连接数均衡：")])]),v._v(" "),_("p",[v._v("负载均衡器的实现分为： 软件均衡器和硬件均衡器。")]),v._v(" "),_("p",[v._v("在软件均衡器方面，又分为直接建设在操作系统内核的均衡器和应用程序形式的均衡器两种。前者的代表是 LVS（Linux Virtual Server），后者的代表有 Nginx、HAProxy、KeepAlived 等，前者性能会更好，因为无须在内核空间和应用空间中来回复制数据包；而后者的优势是选择广泛，使用方便，功能不受限于内核版本。")]),v._v(" "),_("p",[v._v("在硬件均衡器方面，往往会直接采用"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Application-specific_integrated_circuit",target:"_blank",rel:"noopener noreferrer"}},[v._v("应用专用集成电路"),_("OutboundLink")],1),v._v("（Application Specific Integrated Circuit，ASIC）来实现，有专用处理芯片的支持，避免操作系统层面的损耗，得以达到最高的性能")]),v._v(" "),_("h2",{attrs:{id:"服务端缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端缓存"}},[v._v("#")]),v._v(" 服务端缓存")]),v._v(" "),_("p",[v._v("软件开发引入缓存的负面作用：")]),v._v(" "),_("ul",[_("li",[v._v("提高系统复杂度，需要考虑缓存的失效、更新、一致性问题。")]),v._v(" "),_("li",[v._v("缓存会掩盖掉一些缺陷，让问题再更久的时间后出现。")]),v._v(" "),_("li",[v._v("缓存可能泄露某些保密数据。\n引入缓存的目的：")]),v._v(" "),_("li",[v._v("缓解CPU压力。实时计算转换为提前计算，数据复用。")]),v._v(" "),_("li",[v._v("缓解I/O压力。")])]),v._v(" "),_("blockquote",[_("p",[v._v("缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解 CPU 和 I/O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。")])]),v._v(" "),_("p",[v._v("设计和选择缓存需要考虑的维度：")]),v._v(" "),_("ul",[_("li",[v._v("吞吐量： 缓存的吞吐量使用 OPS 值（每秒操作数，Operations per Second，ops/s）来衡量，反映了对缓存进行"),_("strong",[v._v("并发")]),v._v("读、写操作的效率，即缓存本身的工作效率高低。")]),v._v(" "),_("li",[v._v("命中率： 缓存的命中率即成功从缓存中返回结果次数与总请求次数的比值，反映了引入缓存的价值高低，命中率越低，引入缓存的收益越小，价值越低。")]),v._v(" "),_("li",[v._v("拓展功能： 缓存除了基本读写功能外，还提供哪些额外的管理功能，譬如最大容量、失效时间、失效事件、命中率统计，等等。")]),v._v(" "),_("li",[v._v("分布式支持： 缓存可分为“进程内缓存”和“分布式缓存”两大类，前者只为节点本身提供服务，无网络访问操作，速度快但缓存的数据不能在各个服务节点中共享，后者则相反。")])]),v._v(" "),_("blockquote",[_("p",[v._v("缓存中最主要的数据竞争源于读取数据的同时，也会伴随着对数据状态的写入操作，写入数据的同时，也会伴随着数据状态的读取操作。")])]),v._v(" "),_("p",[v._v("最基础的缓存淘汰策略：")]),v._v(" "),_("ul",[_("li",[v._v("FIFO")]),v._v(" "),_("li",[v._v("LRU:最近未被使用访问过的数据。LRU 通常会采用 HashMap 加 LinkedList 双重结构（如 LinkedHashMap）来实现，以 HashMap 来提供访问接口，保证常量时间复杂度的读取性能，以 LinkedList 的链表元素顺序来表示数据的时间顺序，每次缓存命中时把返回对象调整到 LinkedList 开头，每次缓存淘汰时从链表末端开始清理数据。")]),v._v(" "),_("li",[v._v("LFU： 优先淘汰最不经常使用的数据。维护计数。")])]),v._v(" "),_("p",[v._v("对于甚少更新但频繁读取的数据，理论上更适合做复制式缓存；对于更新和读取都较为频繁的数据，理论上就更适合做集中式缓存")]),v._v(" "),_("ul",[_("li",[v._v("复制式缓存：能够支持分布式的进程内缓存”，它的工作原理与 Session 复制类似。缓存中所有数据在分布式集群的每个节点里面都存在有一份副本，读取数据时无须网络访问，直接从当前节点的进程内存中返回，理论上可以做到与进程内缓存一样高的读取性能；当数据发生变化时，就必须遵循复制协议，将变更同步到集群的每个节点中，复制性能随着节点的增加呈现平方级下降，变更数据的代价十分高昂。")]),v._v(" "),_("li",[v._v("集中式缓存：集中式缓存是目前分布式缓存的主流形式，集中式缓存的读、写都需要网络访问，其好处是不会随着集群节点数量的增加而产生额外的负担，其坏处自然是读、写都不再可能达到进程内缓存那样的高性能。")])]),v._v(" "),_("blockquote",[_("p",[v._v("集中式缓存能够为异构语言提供服务，坏处就是缓存对象等复杂情形要进行序列化，传输成本也会变高(需要整体替换)。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/yangxiao2000/md_img/raw/master/images/20240409234635.png",alt:"1712677545800.png",referrerpolicy:"no-referrer"}})]),v._v(" "),_("p",[v._v("多级缓存结合了进程内缓存和分布式缓存的有点，但代码侵入性大。也不便于管理，超时和刷新等。很容易会出现各个节点的一级缓存、以及二级缓存里数据互相不一致的问题。")])])}),[],!1,null,null,null);_.default=a.exports}}]);