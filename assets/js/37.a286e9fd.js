(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{358:function(n,e,t){"use strict";t.r(e);var s=t(17),a=Object(s.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"找出字符串中第一个匹配项的下标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#找出字符串中第一个匹配项的下标"}},[n._v("#")]),n._v(" 找出字符串中第一个匹配项的下标")]),n._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150",target:"_blank",rel:"noopener noreferrer"}},[n._v("原题链接"),e("OutboundLink")],1),n._v("\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。")]),n._v(" "),e("p",[n._v("示例 1：")]),n._v(" "),e("blockquote",[e("p",[n._v('输入：haystack = "sadbutsad", needle = "sad"\n输出：0\n解释："sad" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。')])]),n._v(" "),e("p",[n._v("示例 2：")]),n._v(" "),e("blockquote",[e("p",[n._v('输入：haystack = "leetcode", needle = "leeto"\n输出：-1\n解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。')])]),n._v(" "),e("p",[n._v("提示：")]),n._v(" "),e("ul",[e("li",[n._v("1 <= haystack.length, needle.length <= 104")]),n._v(" "),e("li",[n._v("haystack 和 needle 仅由小写英文字符组成")])]),n._v(" "),e("h2",{attrs:{id:"题解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题解"}},[n._v("#")]),n._v(" 题解")]),n._v(" "),e("blockquote",[e("p",[n._v("kmp算法。 next中存储当前位置前缀和后缀相等的长度。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Solution {\npublic:\n    int strStr(string s, string p) {\n        int n = s.size(), m = p.size();\n        vector<int> next(m , 0);\n   \n        for (int i = 1; i < m; i++) {\n            int j = next[i - 1];\n            while (j > 0 && p[i] != p[j]) {\n                j = next[j - 1];\n            }\n            if (p[i] == p[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n\n        int i = 0, j = 0;\n        while (i < n) {\n            while (j > 0 && s[i] != p[j]) {\n                j = next[j-1];\n            }\n            if (s[i] == p[j]) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n            i++;\n        }\n        return -1;\n    }\n};\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);