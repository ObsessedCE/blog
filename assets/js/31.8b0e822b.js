(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{352:function(t,i,n){"use strict";n.r(i);var e=n(17),h=Object(e.a)({},(function(){var t=this,i=t._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"接雨水"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#接雨水"}},[t._v("#")]),t._v(" 接雨水")]),t._v(" "),i("p",[t._v("给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。")]),t._v(" "),i("p",[t._v("示例 1：")]),t._v(" "),i("blockquote",[i("p",[t._v("输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。")])]),t._v(" "),i("p",[t._v("示例 2：")]),t._v(" "),i("blockquote",[i("p",[t._v("输入：height = [4,2,0,3,2,5]\n输出：9")])]),t._v(" "),i("p",[t._v("提示：")]),t._v(" "),i("ul",[i("li",[t._v("n == height.length")]),t._v(" "),i("li",[t._v("1 <= n <= 2 * 104")]),t._v(" "),i("li",[t._v("0 <= height[i] <= 105")])]),t._v(" "),i("h2",{attrs:{id:"题解"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#题解"}},[t._v("#")]),t._v(" 题解")]),t._v(" "),i("blockquote",[i("p",[t._v("动态规划。可以明显发现当前位置能存储的数量,min(左边最高值, 右边最高值) -heght[i]的结果。使用两个数组分别维护当前位置左边/右边最大值。")])]),t._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        vector<int> leftHight(n);\n        vector<int> rightHight(n);\n        int res = 0;\n        leftHight[0] = height[0];\n        for (int i = 1; i < n; i++) {\n            leftHight[i] = max(leftHight[i-1], height[i]);\n        }\n        rightHight[n-1] = height[n-1];\n        for (int i = n-2; i>=0; i--) {\n            rightHight[i] = max(rightHight[i+1], height[i]);\n        }\n        int tmp = 0;\n        for (int i = 0; i < n;i++) {\n            tmp = min(leftHight[i], rightHight[i]);\n            res += max(0, tmp-height[i]);\n        }\n        return res;\n    }\n};\n")])])]),i("blockquote",[i("p",[t._v("通过双指针减少两个数组的空间占用。leftMax维护左侧当前最高值，rightMax维护右侧当前最高值。res[i] = min(leftMax, rightMax)- height[i]。")])]),t._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans = 0;\n        int left = 0, right = height.size()-1;\n        int leftMax = 0, rightMax = 0;\n        while (left < right) {\n            leftMax = max(leftMax, height[left]);\n            rightMax = max(rightMax, height[right]);\n            if (height[left] < height[right]) {\n                ans += leftMax - height[left];\n                left++;\n            } else {\n                ans += rightMax - height[right];\n                right--;\n            }\n        }\n        return ans;\n    }\n};\n")])])]),i("blockquote",[i("p",[t._v("维护单调递减的栈，当前位置高度大于栈顶位置高度时，栈顶元素出栈。会形成凹陷，当前位置和最新栈顶位置会形成凹陷，从而可以储存水。本质是将水一层一层累加。")])]),t._v(" "),i("p",[i("img",{attrs:{src:"https://i-blog.csdnimg.cn/direct/76eb2c627a09496f9c366d0694932510.png",alt:"在这里插入图片描述",referrerpolicy:"no-referrer"}})]),t._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int res = 0;\n        stack<int> stk;\n        int n = height.size();\n        for (int i = 0; i < n; i++) {\n            while (!stk.empty() && height[i] > height[stk.top()]) {\n                int top = stk.pop();\n                if (stk.empty()) {\n                    break;\n                }\n                int left = stk.pop();\n                int width = i - left -1;\n                int currentHeight = min(height[left], left[i]) - height[top];\n                res += width * currentHeight;\n            }\n            stk.push(i);\n        }\n        return res;\n    }\n};\n")])])])])}),[],!1,null,null,null);i.default=h.exports}}]);