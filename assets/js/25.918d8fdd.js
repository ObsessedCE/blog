(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{345:function(n,s,t){"use strict";t.r(s);var e=t(17),u=Object(e.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"合并两个有序数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并两个有序数组"}},[n._v("#")]),n._v(" 合并两个有序数组")]),n._v(" "),s("p",[s("a",{attrs:{href:"https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150",target:"_blank",rel:"noopener noreferrer"}},[n._v("原题链接"),s("OutboundLink")],1)]),n._v(" "),s("blockquote",[s("p",[n._v("给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。")])]),n._v(" "),s("p",[n._v("示例 1：")]),n._v(" "),s("blockquote",[s("p",[n._v("输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n解释：需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。")])]),n._v(" "),s("p",[n._v("示例 2：")]),n._v(" "),s("blockquote",[s("p",[n._v("输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n解释：需要合并 [1] 和 [] 。\n合并结果是 [1] 。")])]),n._v(" "),s("p",[n._v("示例 3：")]),n._v(" "),s("blockquote",[s("p",[n._v("输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n输出：[1]\n解释：需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。")])]),n._v(" "),s("p",[n._v("提示：")]),n._v(" "),s("blockquote",[s("p",[n._v("nums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[j] <= 109")])]),n._v(" "),s("p",[n._v("进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？")]),n._v(" "),s("p",[n._v("题解：")]),n._v(" "),s("blockquote",[s("p",[n._v("从大到小(从右到左)进行排列，不需要占据额外空间，时间复杂度为O(m+n)")])]),n._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int index = m + n -1;\n        int i1 = m - 1;\n        int i2 = n - 1;\n        while (index >= 0) {\n            if (i1 < 0 || (i2 >= 0 && nums1[i1] < nums2[i2])) {\n                nums1[index--] = nums2[i2--];\n            } else {\n                nums1[index--] = nums1[i1--];\n            }\n        }\n    }\n};\n")])])])])}),[],!1,null,null,null);s.default=u.exports}}]);